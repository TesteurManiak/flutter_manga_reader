// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'source_manga.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

SourceManga _$SourceMangaFromJson(Map<String, dynamic> json) {
  return _SourceManga.fromJson(json);
}

/// @nodoc
mixin _$SourceManga {
  String get url => throw _privateConstructorUsedError;
  String get title => throw _privateConstructorUsedError;
  String? get artist => throw _privateConstructorUsedError;
  String? get author => throw _privateConstructorUsedError;
  String? get description => throw _privateConstructorUsedError;
  String? get genre => throw _privateConstructorUsedError;
  MangaStatus get status => throw _privateConstructorUsedError;
  String? get thumbnailUrl => throw _privateConstructorUsedError;
  bool get initialized => throw _privateConstructorUsedError;
  UpdateStrategy get updateStrategy => throw _privateConstructorUsedError;
  String get sourceId => throw _privateConstructorUsedError;

  /// Create a copy of SourceManga
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SourceMangaCopyWith<SourceManga> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SourceMangaCopyWith<$Res> {
  factory $SourceMangaCopyWith(
          SourceManga value, $Res Function(SourceManga) then) =
      _$SourceMangaCopyWithImpl<$Res, SourceManga>;
  @useResult
  $Res call(
      {String url,
      String title,
      String? artist,
      String? author,
      String? description,
      String? genre,
      MangaStatus status,
      String? thumbnailUrl,
      bool initialized,
      UpdateStrategy updateStrategy,
      String sourceId});
}

/// @nodoc
class _$SourceMangaCopyWithImpl<$Res, $Val extends SourceManga>
    implements $SourceMangaCopyWith<$Res> {
  _$SourceMangaCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SourceManga
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? url = null,
    Object? title = null,
    Object? artist = freezed,
    Object? author = freezed,
    Object? description = freezed,
    Object? genre = freezed,
    Object? status = null,
    Object? thumbnailUrl = freezed,
    Object? initialized = null,
    Object? updateStrategy = null,
    Object? sourceId = null,
  }) {
    return _then(_value.copyWith(
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      artist: freezed == artist
          ? _value.artist
          : artist // ignore: cast_nullable_to_non_nullable
              as String?,
      author: freezed == author
          ? _value.author
          : author // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      genre: freezed == genre
          ? _value.genre
          : genre // ignore: cast_nullable_to_non_nullable
              as String?,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as MangaStatus,
      thumbnailUrl: freezed == thumbnailUrl
          ? _value.thumbnailUrl
          : thumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      initialized: null == initialized
          ? _value.initialized
          : initialized // ignore: cast_nullable_to_non_nullable
              as bool,
      updateStrategy: null == updateStrategy
          ? _value.updateStrategy
          : updateStrategy // ignore: cast_nullable_to_non_nullable
              as UpdateStrategy,
      sourceId: null == sourceId
          ? _value.sourceId
          : sourceId // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SourceMangaImplCopyWith<$Res>
    implements $SourceMangaCopyWith<$Res> {
  factory _$$SourceMangaImplCopyWith(
          _$SourceMangaImpl value, $Res Function(_$SourceMangaImpl) then) =
      __$$SourceMangaImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String url,
      String title,
      String? artist,
      String? author,
      String? description,
      String? genre,
      MangaStatus status,
      String? thumbnailUrl,
      bool initialized,
      UpdateStrategy updateStrategy,
      String sourceId});
}

/// @nodoc
class __$$SourceMangaImplCopyWithImpl<$Res>
    extends _$SourceMangaCopyWithImpl<$Res, _$SourceMangaImpl>
    implements _$$SourceMangaImplCopyWith<$Res> {
  __$$SourceMangaImplCopyWithImpl(
      _$SourceMangaImpl _value, $Res Function(_$SourceMangaImpl) _then)
      : super(_value, _then);

  /// Create a copy of SourceManga
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? url = null,
    Object? title = null,
    Object? artist = freezed,
    Object? author = freezed,
    Object? description = freezed,
    Object? genre = freezed,
    Object? status = null,
    Object? thumbnailUrl = freezed,
    Object? initialized = null,
    Object? updateStrategy = null,
    Object? sourceId = null,
  }) {
    return _then(_$SourceMangaImpl(
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      artist: freezed == artist
          ? _value.artist
          : artist // ignore: cast_nullable_to_non_nullable
              as String?,
      author: freezed == author
          ? _value.author
          : author // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      genre: freezed == genre
          ? _value.genre
          : genre // ignore: cast_nullable_to_non_nullable
              as String?,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as MangaStatus,
      thumbnailUrl: freezed == thumbnailUrl
          ? _value.thumbnailUrl
          : thumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      initialized: null == initialized
          ? _value.initialized
          : initialized // ignore: cast_nullable_to_non_nullable
              as bool,
      updateStrategy: null == updateStrategy
          ? _value.updateStrategy
          : updateStrategy // ignore: cast_nullable_to_non_nullable
              as UpdateStrategy,
      sourceId: null == sourceId
          ? _value.sourceId
          : sourceId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$SourceMangaImpl extends _SourceManga {
  const _$SourceMangaImpl(
      {required this.url,
      required this.title,
      this.artist,
      this.author,
      this.description,
      this.genre,
      this.status = MangaStatus.unknown,
      this.thumbnailUrl,
      this.initialized = false,
      this.updateStrategy = UpdateStrategy.alwaysUpdate,
      required this.sourceId})
      : super._();

  factory _$SourceMangaImpl.fromJson(Map<String, dynamic> json) =>
      _$$SourceMangaImplFromJson(json);

  @override
  final String url;
  @override
  final String title;
  @override
  final String? artist;
  @override
  final String? author;
  @override
  final String? description;
  @override
  final String? genre;
  @override
  @JsonKey()
  final MangaStatus status;
  @override
  final String? thumbnailUrl;
  @override
  @JsonKey()
  final bool initialized;
  @override
  @JsonKey()
  final UpdateStrategy updateStrategy;
  @override
  final String sourceId;

  @override
  String toString() {
    return 'SourceManga(url: $url, title: $title, artist: $artist, author: $author, description: $description, genre: $genre, status: $status, thumbnailUrl: $thumbnailUrl, initialized: $initialized, updateStrategy: $updateStrategy, sourceId: $sourceId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SourceMangaImpl &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.artist, artist) || other.artist == artist) &&
            (identical(other.author, author) || other.author == author) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.genre, genre) || other.genre == genre) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.thumbnailUrl, thumbnailUrl) ||
                other.thumbnailUrl == thumbnailUrl) &&
            (identical(other.initialized, initialized) ||
                other.initialized == initialized) &&
            (identical(other.updateStrategy, updateStrategy) ||
                other.updateStrategy == updateStrategy) &&
            (identical(other.sourceId, sourceId) ||
                other.sourceId == sourceId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      url,
      title,
      artist,
      author,
      description,
      genre,
      status,
      thumbnailUrl,
      initialized,
      updateStrategy,
      sourceId);

  /// Create a copy of SourceManga
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SourceMangaImplCopyWith<_$SourceMangaImpl> get copyWith =>
      __$$SourceMangaImplCopyWithImpl<_$SourceMangaImpl>(this, _$identity);
}

abstract class _SourceManga extends SourceManga {
  const factory _SourceManga(
      {required final String url,
      required final String title,
      final String? artist,
      final String? author,
      final String? description,
      final String? genre,
      final MangaStatus status,
      final String? thumbnailUrl,
      final bool initialized,
      final UpdateStrategy updateStrategy,
      required final String sourceId}) = _$SourceMangaImpl;
  const _SourceManga._() : super._();

  factory _SourceManga.fromJson(Map<String, dynamic> json) =
      _$SourceMangaImpl.fromJson;

  @override
  String get url;
  @override
  String get title;
  @override
  String? get artist;
  @override
  String? get author;
  @override
  String? get description;
  @override
  String? get genre;
  @override
  MangaStatus get status;
  @override
  String? get thumbnailUrl;
  @override
  bool get initialized;
  @override
  UpdateStrategy get updateStrategy;
  @override
  String get sourceId;

  /// Create a copy of SourceManga
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SourceMangaImplCopyWith<_$SourceMangaImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
